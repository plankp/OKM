package com.ymcmp.okm;

import java.util.Map;
import java.util.List;
import java.util.Arrays;
import java.util.ArrayList;

import java.util.logging.Level;

import java.io.IOException;
import java.io.ObjectOutputStream;

import java.nio.file.Path;
import java.nio.file.Files;
import java.nio.file.Paths;

import com.beust.jcommander.Parameter;
import com.beust.jcommander.JCommander;
import com.beust.jcommander.IStringConverter;
import com.beust.jcommander.ParameterException;

import com.ymcmp.okm.opt.*;

import com.ymcmp.okm.tac.Register;
import com.ymcmp.okm.tac.Statement;

import com.ymcmp.okm.runtime.Machine;

import com.ymcmp.okm.converter.Converter;
import com.ymcmp.okm.converter.IRFormatter;
import com.ymcmp.okm.converter.AMD64Converter;

public class App {

    public static class Args {

        @Parameter(converter=PathConverter.class)
        private List<Path> inputPaths = new ArrayList<>();

        @Parameter(names={"--import-path", "-i"}, description="Add directory to import search path", converter=PathConverter.class)
        private List<Path> importPath = new ArrayList<>();

        @Parameter(names={"--debug"}, description="Run compiler in debug mode")
        private boolean debug = false;

        @Parameter(names={"--exec-ir"}, description="Executes intermediate representation after compilation")
        private boolean execIR = false;

        @Parameter(names={"--emit-ir"}, description="Outputs IR, cannot use with --emit-amd64")
        private boolean emitIR = false;

        @Parameter(names={"--emit-amd64"}, description="Converts IR to x86-64 Intel syntax assembly (use with NASM), cannot use with --emit-ir")
        private boolean emitAMD64 = false;

        @Parameter(names={"--output", "-o"}, description="Where to write the output to", converter=PathConverter.class)
        private Path outputPath = null;

        @Parameter(names={"--help", "-h"}, description="Displays help")
        private boolean help = false;
    }

    public static class PathConverter implements IStringConverter<Path> {
        @Override
        public Path convert(String value) {
            return Paths.get(value);
        }
    }

    private static final List<Pass> OPT_PASSES = new ArrayList<>();

    static {
        OPT_PASSES.add(new ReduceMovePass());
        OPT_PASSES.add(new TailCallPass());
        OPT_PASSES.add(new SquashCmpPass());
        OPT_PASSES.add(new ConstantFoldPass());
        OPT_PASSES.add(new EliminateDeadCodePass());
        OPT_PASSES.add(new NormalizeRefGetPass());
        OPT_PASSES.add(new TempParamPass());
        OPT_PASSES.add(new ComSwapPass());
    }

    public static void main(String[] args) {
        final Args argData = new Args();
        final JCommander instance = JCommander.newBuilder()
                .addObject(argData)
                .build();
        try {
            instance.parse(args);
        } catch (ParameterException ex) {
            System.err.println(ex.getMessage());
            instance.usage();
            return;
        }

        if (argData.help) {
            instance.usage();
            return;
        }

        if (argData.inputPaths.isEmpty()) {
            System.err.println("Missing input file");
            return;
        }

        LocalVisitor.LOGGER.setLevel(argData.debug ? Level.INFO : Level.OFF);

        final Map<String, FuncBlock> result = new LocalVisitor(argData.importPath)
                .compile(argData.inputPaths);

        // This line makes sure temporaries generated by optimization passes
        // will never clash with the ones generated by the AST walker (since
        // the AST walker will reset the temporary counter)
        Register.setAdditionalTemporaryPrefix("P");
        final EliminateNopPass eliminateNop = new EliminateNopPass();
        result.forEach((name, func) -> {
            int sizeBeforePass = 0;
            do {
                sizeBeforePass = func.code.size();
                for (final Pass pass : OPT_PASSES) {
                    pass.process(name, func.code);
                    pass.reset();
                    eliminateNop.process(name, func.code);
                    eliminateNop.reset();
                }
            } while (sizeBeforePass != func.code.size());
        });
        Register.resetCounter();

        if (argData.emitIR && argData.emitAMD64) {
            throw new RuntimeException("--emit-ir cannot be used with --emit-amd64");
        }

        if (argData.emitIR) {
            if (argData.outputPath == null) {
                final IRFormatter conv = new IRFormatter();
                result.forEach(conv::convert);
                System.out.println(conv.getResult());
            } else {
                try (final ObjectOutputStream oos = new ObjectOutputStream(Files.newOutputStream(argData.outputPath))) {
                    oos.writeObject(result);
                } catch (IOException ex) {
                    throw new RuntimeException("Cannot emit IR to " + argData.outputPath + ", " + ex.getMessage());
                }
            }
        }

        if (argData.emitAMD64) {
            final AMD64Converter conv = new AMD64Converter();
            result.forEach(conv::convert);
            final String asm = conv.getResult();
            if (argData.outputPath == null) {
                System.out.println(asm);
            } else {
                try {
                    Files.write(argData.outputPath, Arrays.asList(asm));
                } catch (IOException ex) {
                    throw new RuntimeException("Cannot emit AMD64 (NASM) to " + argData.outputPath + ", " + ex.getMessage());
                }
            }
        }

        if (argData.execIR) {
            final Machine machine = new Machine();
            machine.execute(result);
        }
    }
}
